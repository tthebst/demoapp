import { Observable } from 'rxjs';
import { ClrDatagridComparatorInterface } from '../interfaces/comparator.interface';
import { StateDebouncer } from './state-debouncer.provider';
import * as ɵngcc0 from '@angular/core';
export declare class Sort<T = any> {
    private stateDebouncer;
    constructor(stateDebouncer: StateDebouncer);
    /**
     * Currently active comparator
     */
    private _comparator;
    get comparator(): ClrDatagridComparatorInterface<T>;
    set comparator(value: ClrDatagridComparatorInterface<T>);
    /**
     * Ascending order if false, descending if true
     */
    private _reverse;
    get reverse(): boolean;
    set reverse(value: boolean);
    /**
     * The Observable that lets other classes subscribe to sort changes
     */
    private _change;
    private emitChange;
    get change(): Observable<Sort<T>>;
    /**
     * Sets a comparator as the current one, or toggles reverse if the comparator is already used. The
     * optional forceReverse input parameter allows to override that toggling behavior by sorting in
     * reverse order if `true`.
     *
     * @memberof Sort
     */
    toggle(sortBy: ClrDatagridComparatorInterface<T>, forceReverse?: boolean): void;
    /**
     * Clears the current sorting order
     */
    clear(): void;
    /**
     * Compares two objects according to the current comparator
     */
    compare(a: T, b: T): number;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<Sort<any>>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<Sort<any>>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydC5kLnRzIiwic291cmNlcyI6WyJzb3J0LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9jb21wYXJhdG9yLmludGVyZmFjZSc7XG5pbXBvcnQgeyBTdGF0ZURlYm91bmNlciB9IGZyb20gJy4vc3RhdGUtZGVib3VuY2VyLnByb3ZpZGVyJztcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFNvcnQ8VCA9IGFueT4ge1xuICAgIHByaXZhdGUgc3RhdGVEZWJvdW5jZXI7XG4gICAgY29uc3RydWN0b3Ioc3RhdGVEZWJvdW5jZXI6IFN0YXRlRGVib3VuY2VyKTtcbiAgICAvKipcbiAgICAgKiBDdXJyZW50bHkgYWN0aXZlIGNvbXBhcmF0b3JcbiAgICAgKi9cbiAgICBwcml2YXRlIF9jb21wYXJhdG9yO1xuICAgIGdldCBjb21wYXJhdG9yKCk6IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPjtcbiAgICBzZXQgY29tcGFyYXRvcih2YWx1ZTogQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlPFQ+KTtcbiAgICAvKipcbiAgICAgKiBBc2NlbmRpbmcgb3JkZXIgaWYgZmFsc2UsIGRlc2NlbmRpbmcgaWYgdHJ1ZVxuICAgICAqL1xuICAgIHByaXZhdGUgX3JldmVyc2U7XG4gICAgZ2V0IHJldmVyc2UoKTogYm9vbGVhbjtcbiAgICBzZXQgcmV2ZXJzZSh2YWx1ZTogYm9vbGVhbik7XG4gICAgLyoqXG4gICAgICogVGhlIE9ic2VydmFibGUgdGhhdCBsZXRzIG90aGVyIGNsYXNzZXMgc3Vic2NyaWJlIHRvIHNvcnQgY2hhbmdlc1xuICAgICAqL1xuICAgIHByaXZhdGUgX2NoYW5nZTtcbiAgICBwcml2YXRlIGVtaXRDaGFuZ2U7XG4gICAgZ2V0IGNoYW5nZSgpOiBPYnNlcnZhYmxlPFNvcnQ8VD4+O1xuICAgIC8qKlxuICAgICAqIFNldHMgYSBjb21wYXJhdG9yIGFzIHRoZSBjdXJyZW50IG9uZSwgb3IgdG9nZ2xlcyByZXZlcnNlIGlmIHRoZSBjb21wYXJhdG9yIGlzIGFscmVhZHkgdXNlZC4gVGhlXG4gICAgICogb3B0aW9uYWwgZm9yY2VSZXZlcnNlIGlucHV0IHBhcmFtZXRlciBhbGxvd3MgdG8gb3ZlcnJpZGUgdGhhdCB0b2dnbGluZyBiZWhhdmlvciBieSBzb3J0aW5nIGluXG4gICAgICogcmV2ZXJzZSBvcmRlciBpZiBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgU29ydFxuICAgICAqL1xuICAgIHRvZ2dsZShzb3J0Qnk6IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPiwgZm9yY2VSZXZlcnNlPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBjdXJyZW50IHNvcnRpbmcgb3JkZXJcbiAgICAgKi9cbiAgICBjbGVhcigpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHR3byBvYmplY3RzIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBjb21wYXJhdG9yXG4gICAgICovXG4gICAgY29tcGFyZShhOiBULCBiOiBUKTogbnVtYmVyO1xufVxuIl19