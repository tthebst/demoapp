import { EventEmitter, OnDestroy, TemplateRef, ViewContainerRef } from '@angular/core';
import { ClrPopoverToggleService } from '../popover/providers/popover-toggle.service';
import * as ɵngcc0 from '@angular/core';
export declare class ClrIfOpen implements OnDestroy {
    private toggleService;
    private template;
    private container;
    private subscription;
    /*********
     *
     * @description
     * A setter that updates ClrPopoverToggleService.open with value.
     *
     * @param value
     */
    set open(value: boolean);
    /**********
     * @property openChange
     *
     * @description
     * An event emitter that emits when the open property is set to allow for 2way binding when the directive is
     * used with de-structured / de-sugared syntax.
     */
    openChange: EventEmitter<boolean>;
    /********
     *
     * @description
     * A getter that returns the current ClrPopoverToggleService.open value.
     *
     */
    get open(): boolean;
    constructor(toggleService: ClrPopoverToggleService, template: TemplateRef<any>, container: ViewContainerRef);
    /*********
     *
     * @description
     * Function that takes a boolean value and either created an embedded view for the associated ViewContainerRef or,
     * Clears all views from the ViewContainerRef
     * @param value
     */
    updateView(value: boolean): void;
    ngOnDestroy(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<ClrIfOpen>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<ClrIfOpen, "[clrIfOpen]", never, {
    "open": "clrIfOpen";
}, {
    "openChange": "clrIfOpenChange";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWYtb3Blbi5kaXJlY3RpdmUuZC50cyIsInNvdXJjZXMiOlsiaWYtb3Blbi5kaXJlY3RpdmUuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0NBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJQb3BvdmVyVG9nZ2xlU2VydmljZSB9IGZyb20gJy4uL3BvcG92ZXIvcHJvdmlkZXJzL3BvcG92ZXItdG9nZ2xlLnNlcnZpY2UnO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQ2xySWZPcGVuIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIHRvZ2dsZVNlcnZpY2U7XG4gICAgcHJpdmF0ZSB0ZW1wbGF0ZTtcbiAgICBwcml2YXRlIGNvbnRhaW5lcjtcbiAgICBwcml2YXRlIHN1YnNjcmlwdGlvbjtcbiAgICAvKioqKioqKioqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBBIHNldHRlciB0aGF0IHVwZGF0ZXMgQ2xyUG9wb3ZlclRvZ2dsZVNlcnZpY2Uub3BlbiB3aXRoIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgc2V0IG9wZW4odmFsdWU6IGJvb2xlYW4pO1xuICAgIC8qKioqKioqKioqXG4gICAgICogQHByb3BlcnR5IG9wZW5DaGFuZ2VcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEFuIGV2ZW50IGVtaXR0ZXIgdGhhdCBlbWl0cyB3aGVuIHRoZSBvcGVuIHByb3BlcnR5IGlzIHNldCB0byBhbGxvdyBmb3IgMndheSBiaW5kaW5nIHdoZW4gdGhlIGRpcmVjdGl2ZSBpc1xuICAgICAqIHVzZWQgd2l0aCBkZS1zdHJ1Y3R1cmVkIC8gZGUtc3VnYXJlZCBzeW50YXguXG4gICAgICovXG4gICAgb3BlbkNoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+O1xuICAgIC8qKioqKioqKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQSBnZXR0ZXIgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IENsclBvcG92ZXJUb2dnbGVTZXJ2aWNlLm9wZW4gdmFsdWUuXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQgb3BlbigpOiBib29sZWFuO1xuICAgIGNvbnN0cnVjdG9yKHRvZ2dsZVNlcnZpY2U6IENsclBvcG92ZXJUb2dnbGVTZXJ2aWNlLCB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PiwgY29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmKTtcbiAgICAvKioqKioqKioqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBGdW5jdGlvbiB0aGF0IHRha2VzIGEgYm9vbGVhbiB2YWx1ZSBhbmQgZWl0aGVyIGNyZWF0ZWQgYW4gZW1iZWRkZWQgdmlldyBmb3IgdGhlIGFzc29jaWF0ZWQgVmlld0NvbnRhaW5lclJlZiBvcixcbiAgICAgKiBDbGVhcnMgYWxsIHZpZXdzIGZyb20gdGhlIFZpZXdDb250YWluZXJSZWZcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICB1cGRhdGVWaWV3KHZhbHVlOiBib29sZWFuKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xufVxuIl19