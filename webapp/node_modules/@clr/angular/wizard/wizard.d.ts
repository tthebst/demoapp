import { AfterContentInit, DoCheck, ElementRef, EventEmitter, IterableDiffers, OnDestroy, QueryList } from '@angular/core';
import { ButtonHubService } from './providers/button-hub.service';
import { HeaderActionService } from './providers/header-actions.service';
import { PageCollectionService } from './providers/page-collection.service';
import { WizardNavigationService } from './providers/wizard-navigation.service';
import { ClrWizardHeaderAction } from './wizard-header-action';
import { ClrWizardPage } from './wizard-page';
import * as ɵngcc0 from '@angular/core';
export declare class ClrWizard implements OnDestroy, AfterContentInit, DoCheck {
    private platformId;
    navService: WizardNavigationService;
    pageCollection: PageCollectionService;
    buttonService: ButtonHubService;
    headerActionService: HeaderActionService;
    private elementRef;
    /**
     * Set the modal size of the wizard. Set using `[clrWizardSize]` input.
     */
    size: string;
    /**
     * Tells the modal part of the wizard whether it should have a close "X"
     * in the top right corner. Set using `[clrWizardClosable]` input.
     */
    closable: boolean;
    /**
     * Resets page completed states when navigating backwards.
     * Set using `[clrWizardForceForwardNavigation]` input.
     */
    set forceForward(value: boolean);
    private _forceForward;
    get forceForward(): boolean;
    _open: boolean;
    /**
     * Toggles open/close of the wizard component.
     * Set using the `[clrWizardOpen]` input.
     */
    set clrWizardOpen(open: boolean);
    /**
     * Prevents ClrWizard from moving to the next page or closing itself on finishing.
     * Set using the `[clrWizardPreventDefaultNext]` input. Note that using stopNext
     * will require you to create your own calls to .next() and .finish() in your
     * host component to make the ClrWizard work as expected.
     */
    set stopNext(value: boolean);
    private _stopNext;
    get stopNext(): boolean;
    /**
     * Prevents ClrWizard from closing when the cancel button or close "X" is clicked.
     * Set using the `[clrWizardPreventDefaultCancel]` input.
     *
     * Note that using stopCancel will require you to create your own calls to `close()` in your host compone`nt
     * to make the ClrWizard work as expected. Useful for doing checks or prompts
     * before closing a ClrWizard.
     */
    set stopCancel(value: boolean);
    private _stopCancel;
    get stopCancel(): boolean;
    /**
     * Prevents ClrWizard from performing any form of navigation away from the current
     * page. Set using the `[clrWizardPreventNavigation]` input.
     * Note that stopNavigation is meant to freeze the wizard in place, typically
     * during a long validation or background action where you want the wizard to
     * display loading content but not allow the user to execute navigation in
     * the stepnav, close X, or the  back, finish, or next buttons.
     */
    set stopNavigation(value: boolean);
    private _stopNavigation;
    get stopNavigation(): boolean;
    /**
     * Prevents clicks on the links in the stepnav from working.
     * Set using `[clrWizardDisableStepnav]` input.
     * A more granular bypassing of navigation which can be useful when your
     * ClrWizard is in a state of completion and you don't want users to be
     * able to jump backwards and change things.
     */
    set disableStepnav(value: boolean);
    private _disableStepnav;
    get disableStepnav(): boolean;
    /**
     * Used to communicate to the underlying modal that animations are not
     * wanted. Primary use is for the display of static/inline wizards.
     * Set using `[clrWizardPreventModalAnimation]` input.
     */
    /** @deprecated since 3.0, input should be removed in 4.0 because is only related to inline wizards */
    _stopModalAnimations: boolean;
    get stopModalAnimations(): string;
    /**
     * Emits when the wizard is opened or closed.
     * Listen via `(clrWizardOpenChange)` event.
     */
    _openChanged: EventEmitter<boolean>;
    /**
     * Emits when the wizard is canceled. Listen via `(clrWizardOnCancel)` event.
     * Can be combined with the `[clrWizardPreventDefaultCancel]` input to create
     * wizard-level custom cancel routines.
     */
    onCancel: EventEmitter<any>;
    /**
     * Emits when the wizard is completed. Listen via `(clrWizardOnFinish)` event.
     * Can be combined with the `[clrWizardPreventDefaultNext]` input to create
     * wizard-level custom completion routines.
     */
    wizardFinished: EventEmitter<any>;
    /**
     * Emits when the wizard is reset. Listen via `(clrWizardOnReset)` event.
     */
    onReset: EventEmitter<any>;
    /**
     * Emits when the current page has changed. Listen via `(clrWizardCurrentPageChanged)` event.
     * output. Useful for non-blocking validation.
     */
    currentPageChanged: EventEmitter<any>;
    /**
     * Emits when the wizard moves to the next page. Listen via `(clrWizardOnNext)` event.
     * Can be combined with the `[clrWizardPreventDefaultNext]` input to create
     * wizard-level custom navigation routines, which are useful for validation.
     */
    onMoveNext: EventEmitter<any>;
    /**
     * Emits when the wizard moves to the previous page. Can be useful for validation.
     * Listen via `(clrWizardOnPrevious)` event.
     */
    onMovePrevious: EventEmitter<any>;
    pages: QueryList<ClrWizardPage>;
    headerActions: QueryList<ClrWizardHeaderAction>;
    wizardTitle: ElementRef;
    get currentPage(): ClrWizardPage;
    set currentPage(page: ClrWizardPage);
    get isLast(): boolean;
    get isFirst(): boolean;
    get isStatic(): boolean;
    private differ;
    private subscriptions;
    constructor(platformId: Object, navService: WizardNavigationService, pageCollection: PageCollectionService, buttonService: ButtonHubService, headerActionService: HeaderActionService, elementRef: ElementRef, differs: IterableDiffers);
    ngAfterContentInit(): void;
    ngDoCheck(): void;
    ngOnDestroy(): void;
    /**
     * Marks Wizard as finished. By default it does not execute event
     * emissions or checks before completing and closing. This method is commonly
     * used as part of an alternative navigation with `[clrWizardPreventDefaultNext]`.
     *
     * If `skipChecksAndEmits` is true, the wizard will complete and close
     * regardless of the state of its current page. This is useful for alternative
     * navigation where event emissions have already been done and firing them again
     * may cause an event loop.
     */
    finish(skipChecksAndEmits?: boolean): void;
    /**
     * Marks the wizard as finished but does run checks and emissions.
     * Good for a last step in an alternate workflow. Does the same thing as
     * calling `ClrWizard.finish(true)` or `ClrWizard.finish()` without a parameter.
     */
    forceFinish(): void;
    /**
     * Opens the wizard. If there is no current page defined, sets the first page in the wizard to be current.
     */
    open(): void;
    /**
     * Closes the wizard. Call this directly instead of `cancel()` to implement alternative cancel functionality.
     */
    close(): void;
    /**
     * Used to open and close the wizard. By default the wizard will
     * close if invoked with no parameter. If parameter is true wizard will open
     * else if false will close.
     */
    toggle(open: boolean): void;
    /**
     * Moves the wizard to the previous page.
     */
    previous(): void;
    /**
     * By default, `next()` does not execute event emissions.
     * This method is commonly called as part of an alternative navigation
     * with `[clrWizardPreventDefaultNext]`. The wizard will move to the next page
     * regardless of the state of its current page. This is useful for alternative
     * navigation where event emissions have already been done and firing them again
     * may cause an event loop.
     *
     * If `skipChecksAndEmits` is false, the wizard will execute default checks
     * and emit events as normal. This is useful for custom buttons or programmatic
     * workflows that are not executing the wizards default checks and emissions.
     * It is another way to navigate without having to rewrite the wizard’s default
     * functionality from scratch.
     */
    next(skipChecksAndEmits?: boolean): void;
    /**
     * Moves the wizard to the next page without the checks and emissions.
     * Good for a last step in an alternate workflow.
     * Alias for `ClrWizard.next(true)` or `ClrWizard.next()`
     */
    forceNext(): void;
    /**
     * Cancels and closes the wizard. Do not use this for an override of the cancel
     * the functionality with `[clrWizardPreventDefaultCancel]`, `[clrWizardPreventPageDefaultCancel]`,
     * or `[clrWizardPagePreventDefault]` because it will initiate the same checks
     * and event emissions that invoked your event handler. Use `ClrWizard.close()` instead.
     */
    cancel(): void;
    /**
     * Overrides behavior of the underlying modal to avoid collisions with
     * alternative cancel functionality. In most cases, use `ClrWizard.cancel()` instead.
     */
    modalCancel(): void;
    /**
     * Checks for alternative cancel flows defined at the current page or
     * wizard level. Performs a canceled if not. Emits events that initiate
     * the alternative cancel outputs `(clrWizardPageOnCancel)` and `(clrWizardOnCancel)`.
     */
    checkAndCancel(): void;
    /**
     * Navigates to a given page in the Wizard. Navigation will invoke the wizard’s default
     * checks and event emissions.
     *
     * The format of the expected ID parameter can be found in the return of the
     * ClrWizardPage.id getter, usually prefixed with `clr-wizard-page-` and then either a
     * numeric ID or the ID specified for the `ClrWizardPage` component’s `id` input.
     */
    goTo(pageId: string): void;
    /**
     * Reset sets all WizardPages to incomplete and sets the first page in the `ClrWizard` to
     * be the current page, resetting the wizard navigation.
     * Use `(clrWizardOnReset)` event to reset the data or model of your wizard.
     */
    reset(): void;
    private listenForNextPageChanges;
    private listenForPreviousPageChanges;
    private listenForCancelChanges;
    private listenForFinishedChanges;
    private listenForPageChanges;
    private updateNavOnPageChanges;
    private initializeButtons;
    private emitWizardFinished;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<ClrWizard>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<ClrWizard, "clr-wizard", never, {
    "size": "clrWizardSize";
    "closable": "clrWizardClosable";
    "_stopModalAnimations": "clrWizardPreventModalAnimation";
    "forceForward": "clrWizardForceForwardNavigation";
    "clrWizardOpen": "clrWizardOpen";
    "stopNext": "clrWizardPreventDefaultNext";
    "stopCancel": "clrWizardPreventDefaultCancel";
    "stopNavigation": "clrWizardPreventNavigation";
    "disableStepnav": "clrWizardDisableStepnav";
}, {
    "_openChanged": "clrWizardOpenChange";
    "onCancel": "clrWizardOnCancel";
    "wizardFinished": "clrWizardOnFinish";
    "onReset": "clrWizardOnReset";
    "currentPageChanged": "clrWizardCurrentPageChanged";
    "onMoveNext": "clrWizardOnNext";
    "onMovePrevious": "clrWizardOnPrevious";
}, ["pages", "headerActions"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2l6YXJkLmQudHMiLCJzb3VyY2VzIjpbIndpemFyZC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztBQU9BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrT0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBEb0NoZWNrLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEl0ZXJhYmxlRGlmZmVycywgT25EZXN0cm95LCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJ1dHRvbkh1YlNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9idXR0b24taHViLnNlcnZpY2UnO1xuaW1wb3J0IHsgSGVhZGVyQWN0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2hlYWRlci1hY3Rpb25zLnNlcnZpY2UnO1xuaW1wb3J0IHsgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvcGFnZS1jb2xsZWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy93aXphcmQtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IENscldpemFyZEhlYWRlckFjdGlvbiB9IGZyb20gJy4vd2l6YXJkLWhlYWRlci1hY3Rpb24nO1xuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZSB9IGZyb20gJy4vd2l6YXJkLXBhZ2UnO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQ2xyV2l6YXJkIGltcGxlbWVudHMgT25EZXN0cm95LCBBZnRlckNvbnRlbnRJbml0LCBEb0NoZWNrIHtcbiAgICBwcml2YXRlIHBsYXRmb3JtSWQ7XG4gICAgbmF2U2VydmljZTogV2l6YXJkTmF2aWdhdGlvblNlcnZpY2U7XG4gICAgcGFnZUNvbGxlY3Rpb246IFBhZ2VDb2xsZWN0aW9uU2VydmljZTtcbiAgICBidXR0b25TZXJ2aWNlOiBCdXR0b25IdWJTZXJ2aWNlO1xuICAgIGhlYWRlckFjdGlvblNlcnZpY2U6IEhlYWRlckFjdGlvblNlcnZpY2U7XG4gICAgcHJpdmF0ZSBlbGVtZW50UmVmO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbW9kYWwgc2l6ZSBvZiB0aGUgd2l6YXJkLiBTZXQgdXNpbmcgYFtjbHJXaXphcmRTaXplXWAgaW5wdXQuXG4gICAgICovXG4gICAgc2l6ZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSBtb2RhbCBwYXJ0IG9mIHRoZSB3aXphcmQgd2hldGhlciBpdCBzaG91bGQgaGF2ZSBhIGNsb3NlIFwiWFwiXG4gICAgICogaW4gdGhlIHRvcCByaWdodCBjb3JuZXIuIFNldCB1c2luZyBgW2NscldpemFyZENsb3NhYmxlXWAgaW5wdXQuXG4gICAgICovXG4gICAgY2xvc2FibGU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHBhZ2UgY29tcGxldGVkIHN0YXRlcyB3aGVuIG5hdmlnYXRpbmcgYmFja3dhcmRzLlxuICAgICAqIFNldCB1c2luZyBgW2NscldpemFyZEZvcmNlRm9yd2FyZE5hdmlnYXRpb25dYCBpbnB1dC5cbiAgICAgKi9cbiAgICBzZXQgZm9yY2VGb3J3YXJkKHZhbHVlOiBib29sZWFuKTtcbiAgICBwcml2YXRlIF9mb3JjZUZvcndhcmQ7XG4gICAgZ2V0IGZvcmNlRm9yd2FyZCgpOiBib29sZWFuO1xuICAgIF9vcGVuOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgb3Blbi9jbG9zZSBvZiB0aGUgd2l6YXJkIGNvbXBvbmVudC5cbiAgICAgKiBTZXQgdXNpbmcgdGhlIGBbY2xyV2l6YXJkT3Blbl1gIGlucHV0LlxuICAgICAqL1xuICAgIHNldCBjbHJXaXphcmRPcGVuKG9wZW46IGJvb2xlYW4pO1xuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIENscldpemFyZCBmcm9tIG1vdmluZyB0byB0aGUgbmV4dCBwYWdlIG9yIGNsb3NpbmcgaXRzZWxmIG9uIGZpbmlzaGluZy5cbiAgICAgKiBTZXQgdXNpbmcgdGhlIGBbY2xyV2l6YXJkUHJldmVudERlZmF1bHROZXh0XWAgaW5wdXQuIE5vdGUgdGhhdCB1c2luZyBzdG9wTmV4dFxuICAgICAqIHdpbGwgcmVxdWlyZSB5b3UgdG8gY3JlYXRlIHlvdXIgb3duIGNhbGxzIHRvIC5uZXh0KCkgYW5kIC5maW5pc2goKSBpbiB5b3VyXG4gICAgICogaG9zdCBjb21wb25lbnQgdG8gbWFrZSB0aGUgQ2xyV2l6YXJkIHdvcmsgYXMgZXhwZWN0ZWQuXG4gICAgICovXG4gICAgc2V0IHN0b3BOZXh0KHZhbHVlOiBib29sZWFuKTtcbiAgICBwcml2YXRlIF9zdG9wTmV4dDtcbiAgICBnZXQgc3RvcE5leHQoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBQcmV2ZW50cyBDbHJXaXphcmQgZnJvbSBjbG9zaW5nIHdoZW4gdGhlIGNhbmNlbCBidXR0b24gb3IgY2xvc2UgXCJYXCIgaXMgY2xpY2tlZC5cbiAgICAgKiBTZXQgdXNpbmcgdGhlIGBbY2xyV2l6YXJkUHJldmVudERlZmF1bHRDYW5jZWxdYCBpbnB1dC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB1c2luZyBzdG9wQ2FuY2VsIHdpbGwgcmVxdWlyZSB5b3UgdG8gY3JlYXRlIHlvdXIgb3duIGNhbGxzIHRvIGBjbG9zZSgpYCBpbiB5b3VyIGhvc3QgY29tcG9uZWBudFxuICAgICAqIHRvIG1ha2UgdGhlIENscldpemFyZCB3b3JrIGFzIGV4cGVjdGVkLiBVc2VmdWwgZm9yIGRvaW5nIGNoZWNrcyBvciBwcm9tcHRzXG4gICAgICogYmVmb3JlIGNsb3NpbmcgYSBDbHJXaXphcmQuXG4gICAgICovXG4gICAgc2V0IHN0b3BDYW5jZWwodmFsdWU6IGJvb2xlYW4pO1xuICAgIHByaXZhdGUgX3N0b3BDYW5jZWw7XG4gICAgZ2V0IHN0b3BDYW5jZWwoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBQcmV2ZW50cyBDbHJXaXphcmQgZnJvbSBwZXJmb3JtaW5nIGFueSBmb3JtIG9mIG5hdmlnYXRpb24gYXdheSBmcm9tIHRoZSBjdXJyZW50XG4gICAgICogcGFnZS4gU2V0IHVzaW5nIHRoZSBgW2NscldpemFyZFByZXZlbnROYXZpZ2F0aW9uXWAgaW5wdXQuXG4gICAgICogTm90ZSB0aGF0IHN0b3BOYXZpZ2F0aW9uIGlzIG1lYW50IHRvIGZyZWV6ZSB0aGUgd2l6YXJkIGluIHBsYWNlLCB0eXBpY2FsbHlcbiAgICAgKiBkdXJpbmcgYSBsb25nIHZhbGlkYXRpb24gb3IgYmFja2dyb3VuZCBhY3Rpb24gd2hlcmUgeW91IHdhbnQgdGhlIHdpemFyZCB0b1xuICAgICAqIGRpc3BsYXkgbG9hZGluZyBjb250ZW50IGJ1dCBub3QgYWxsb3cgdGhlIHVzZXIgdG8gZXhlY3V0ZSBuYXZpZ2F0aW9uIGluXG4gICAgICogdGhlIHN0ZXBuYXYsIGNsb3NlIFgsIG9yIHRoZSAgYmFjaywgZmluaXNoLCBvciBuZXh0IGJ1dHRvbnMuXG4gICAgICovXG4gICAgc2V0IHN0b3BOYXZpZ2F0aW9uKHZhbHVlOiBib29sZWFuKTtcbiAgICBwcml2YXRlIF9zdG9wTmF2aWdhdGlvbjtcbiAgICBnZXQgc3RvcE5hdmlnYXRpb24oKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBQcmV2ZW50cyBjbGlja3Mgb24gdGhlIGxpbmtzIGluIHRoZSBzdGVwbmF2IGZyb20gd29ya2luZy5cbiAgICAgKiBTZXQgdXNpbmcgYFtjbHJXaXphcmREaXNhYmxlU3RlcG5hdl1gIGlucHV0LlxuICAgICAqIEEgbW9yZSBncmFudWxhciBieXBhc3Npbmcgb2YgbmF2aWdhdGlvbiB3aGljaCBjYW4gYmUgdXNlZnVsIHdoZW4geW91clxuICAgICAqIENscldpemFyZCBpcyBpbiBhIHN0YXRlIG9mIGNvbXBsZXRpb24gYW5kIHlvdSBkb24ndCB3YW50IHVzZXJzIHRvIGJlXG4gICAgICogYWJsZSB0byBqdW1wIGJhY2t3YXJkcyBhbmQgY2hhbmdlIHRoaW5ncy5cbiAgICAgKi9cbiAgICBzZXQgZGlzYWJsZVN0ZXBuYXYodmFsdWU6IGJvb2xlYW4pO1xuICAgIHByaXZhdGUgX2Rpc2FibGVTdGVwbmF2O1xuICAgIGdldCBkaXNhYmxlU3RlcG5hdigpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gY29tbXVuaWNhdGUgdG8gdGhlIHVuZGVybHlpbmcgbW9kYWwgdGhhdCBhbmltYXRpb25zIGFyZSBub3RcbiAgICAgKiB3YW50ZWQuIFByaW1hcnkgdXNlIGlzIGZvciB0aGUgZGlzcGxheSBvZiBzdGF0aWMvaW5saW5lIHdpemFyZHMuXG4gICAgICogU2V0IHVzaW5nIGBbY2xyV2l6YXJkUHJldmVudE1vZGFsQW5pbWF0aW9uXWAgaW5wdXQuXG4gICAgICovXG4gICAgLyoqIEBkZXByZWNhdGVkIHNpbmNlIDMuMCwgaW5wdXQgc2hvdWxkIGJlIHJlbW92ZWQgaW4gNC4wIGJlY2F1c2UgaXMgb25seSByZWxhdGVkIHRvIGlubGluZSB3aXphcmRzICovXG4gICAgX3N0b3BNb2RhbEFuaW1hdGlvbnM6IGJvb2xlYW47XG4gICAgZ2V0IHN0b3BNb2RhbEFuaW1hdGlvbnMoKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gdGhlIHdpemFyZCBpcyBvcGVuZWQgb3IgY2xvc2VkLlxuICAgICAqIExpc3RlbiB2aWEgYChjbHJXaXphcmRPcGVuQ2hhbmdlKWAgZXZlbnQuXG4gICAgICovXG4gICAgX29wZW5DaGFuZ2VkOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj47XG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgd2l6YXJkIGlzIGNhbmNlbGVkLiBMaXN0ZW4gdmlhIGAoY2xyV2l6YXJkT25DYW5jZWwpYCBldmVudC5cbiAgICAgKiBDYW4gYmUgY29tYmluZWQgd2l0aCB0aGUgYFtjbHJXaXphcmRQcmV2ZW50RGVmYXVsdENhbmNlbF1gIGlucHV0IHRvIGNyZWF0ZVxuICAgICAqIHdpemFyZC1sZXZlbCBjdXN0b20gY2FuY2VsIHJvdXRpbmVzLlxuICAgICAqL1xuICAgIG9uQ2FuY2VsOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB3aXphcmQgaXMgY29tcGxldGVkLiBMaXN0ZW4gdmlhIGAoY2xyV2l6YXJkT25GaW5pc2gpYCBldmVudC5cbiAgICAgKiBDYW4gYmUgY29tYmluZWQgd2l0aCB0aGUgYFtjbHJXaXphcmRQcmV2ZW50RGVmYXVsdE5leHRdYCBpbnB1dCB0byBjcmVhdGVcbiAgICAgKiB3aXphcmQtbGV2ZWwgY3VzdG9tIGNvbXBsZXRpb24gcm91dGluZXMuXG4gICAgICovXG4gICAgd2l6YXJkRmluaXNoZWQ6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gdGhlIHdpemFyZCBpcyByZXNldC4gTGlzdGVuIHZpYSBgKGNscldpemFyZE9uUmVzZXQpYCBldmVudC5cbiAgICAgKi9cbiAgICBvblJlc2V0OiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSBjdXJyZW50IHBhZ2UgaGFzIGNoYW5nZWQuIExpc3RlbiB2aWEgYChjbHJXaXphcmRDdXJyZW50UGFnZUNoYW5nZWQpYCBldmVudC5cbiAgICAgKiBvdXRwdXQuIFVzZWZ1bCBmb3Igbm9uLWJsb2NraW5nIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgY3VycmVudFBhZ2VDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB3aXphcmQgbW92ZXMgdG8gdGhlIG5leHQgcGFnZS4gTGlzdGVuIHZpYSBgKGNscldpemFyZE9uTmV4dClgIGV2ZW50LlxuICAgICAqIENhbiBiZSBjb21iaW5lZCB3aXRoIHRoZSBgW2NscldpemFyZFByZXZlbnREZWZhdWx0TmV4dF1gIGlucHV0IHRvIGNyZWF0ZVxuICAgICAqIHdpemFyZC1sZXZlbCBjdXN0b20gbmF2aWdhdGlvbiByb3V0aW5lcywgd2hpY2ggYXJlIHVzZWZ1bCBmb3IgdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBvbk1vdmVOZXh0OiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB3aXphcmQgbW92ZXMgdG8gdGhlIHByZXZpb3VzIHBhZ2UuIENhbiBiZSB1c2VmdWwgZm9yIHZhbGlkYXRpb24uXG4gICAgICogTGlzdGVuIHZpYSBgKGNscldpemFyZE9uUHJldmlvdXMpYCBldmVudC5cbiAgICAgKi9cbiAgICBvbk1vdmVQcmV2aW91czogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgcGFnZXM6IFF1ZXJ5TGlzdDxDbHJXaXphcmRQYWdlPjtcbiAgICBoZWFkZXJBY3Rpb25zOiBRdWVyeUxpc3Q8Q2xyV2l6YXJkSGVhZGVyQWN0aW9uPjtcbiAgICB3aXphcmRUaXRsZTogRWxlbWVudFJlZjtcbiAgICBnZXQgY3VycmVudFBhZ2UoKTogQ2xyV2l6YXJkUGFnZTtcbiAgICBzZXQgY3VycmVudFBhZ2UocGFnZTogQ2xyV2l6YXJkUGFnZSk7XG4gICAgZ2V0IGlzTGFzdCgpOiBib29sZWFuO1xuICAgIGdldCBpc0ZpcnN0KCk6IGJvb2xlYW47XG4gICAgZ2V0IGlzU3RhdGljKCk6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBkaWZmZXI7XG4gICAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zO1xuICAgIGNvbnN0cnVjdG9yKHBsYXRmb3JtSWQ6IE9iamVjdCwgbmF2U2VydmljZTogV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UsIHBhZ2VDb2xsZWN0aW9uOiBQYWdlQ29sbGVjdGlvblNlcnZpY2UsIGJ1dHRvblNlcnZpY2U6IEJ1dHRvbkh1YlNlcnZpY2UsIGhlYWRlckFjdGlvblNlcnZpY2U6IEhlYWRlckFjdGlvblNlcnZpY2UsIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGRpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycyk7XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XG4gICAgbmdEb0NoZWNrKCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBNYXJrcyBXaXphcmQgYXMgZmluaXNoZWQuIEJ5IGRlZmF1bHQgaXQgZG9lcyBub3QgZXhlY3V0ZSBldmVudFxuICAgICAqIGVtaXNzaW9ucyBvciBjaGVja3MgYmVmb3JlIGNvbXBsZXRpbmcgYW5kIGNsb3NpbmcuIFRoaXMgbWV0aG9kIGlzIGNvbW1vbmx5XG4gICAgICogdXNlZCBhcyBwYXJ0IG9mIGFuIGFsdGVybmF0aXZlIG5hdmlnYXRpb24gd2l0aCBgW2NscldpemFyZFByZXZlbnREZWZhdWx0TmV4dF1gLlxuICAgICAqXG4gICAgICogSWYgYHNraXBDaGVja3NBbmRFbWl0c2AgaXMgdHJ1ZSwgdGhlIHdpemFyZCB3aWxsIGNvbXBsZXRlIGFuZCBjbG9zZVxuICAgICAqIHJlZ2FyZGxlc3Mgb2YgdGhlIHN0YXRlIG9mIGl0cyBjdXJyZW50IHBhZ2UuIFRoaXMgaXMgdXNlZnVsIGZvciBhbHRlcm5hdGl2ZVxuICAgICAqIG5hdmlnYXRpb24gd2hlcmUgZXZlbnQgZW1pc3Npb25zIGhhdmUgYWxyZWFkeSBiZWVuIGRvbmUgYW5kIGZpcmluZyB0aGVtIGFnYWluXG4gICAgICogbWF5IGNhdXNlIGFuIGV2ZW50IGxvb3AuXG4gICAgICovXG4gICAgZmluaXNoKHNraXBDaGVja3NBbmRFbWl0cz86IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoZSB3aXphcmQgYXMgZmluaXNoZWQgYnV0IGRvZXMgcnVuIGNoZWNrcyBhbmQgZW1pc3Npb25zLlxuICAgICAqIEdvb2QgZm9yIGEgbGFzdCBzdGVwIGluIGFuIGFsdGVybmF0ZSB3b3JrZmxvdy4gRG9lcyB0aGUgc2FtZSB0aGluZyBhc1xuICAgICAqIGNhbGxpbmcgYENscldpemFyZC5maW5pc2godHJ1ZSlgIG9yIGBDbHJXaXphcmQuZmluaXNoKClgIHdpdGhvdXQgYSBwYXJhbWV0ZXIuXG4gICAgICovXG4gICAgZm9yY2VGaW5pc2goKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgd2l6YXJkLiBJZiB0aGVyZSBpcyBubyBjdXJyZW50IHBhZ2UgZGVmaW5lZCwgc2V0cyB0aGUgZmlyc3QgcGFnZSBpbiB0aGUgd2l6YXJkIHRvIGJlIGN1cnJlbnQuXG4gICAgICovXG4gICAgb3BlbigpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgd2l6YXJkLiBDYWxsIHRoaXMgZGlyZWN0bHkgaW5zdGVhZCBvZiBgY2FuY2VsKClgIHRvIGltcGxlbWVudCBhbHRlcm5hdGl2ZSBjYW5jZWwgZnVuY3Rpb25hbGl0eS5cbiAgICAgKi9cbiAgICBjbG9zZSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gb3BlbiBhbmQgY2xvc2UgdGhlIHdpemFyZC4gQnkgZGVmYXVsdCB0aGUgd2l6YXJkIHdpbGxcbiAgICAgKiBjbG9zZSBpZiBpbnZva2VkIHdpdGggbm8gcGFyYW1ldGVyLiBJZiBwYXJhbWV0ZXIgaXMgdHJ1ZSB3aXphcmQgd2lsbCBvcGVuXG4gICAgICogZWxzZSBpZiBmYWxzZSB3aWxsIGNsb3NlLlxuICAgICAqL1xuICAgIHRvZ2dsZShvcGVuOiBib29sZWFuKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0aGUgd2l6YXJkIHRvIHRoZSBwcmV2aW91cyBwYWdlLlxuICAgICAqL1xuICAgIHByZXZpb3VzKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgYG5leHQoKWAgZG9lcyBub3QgZXhlY3V0ZSBldmVudCBlbWlzc2lvbnMuXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29tbW9ubHkgY2FsbGVkIGFzIHBhcnQgb2YgYW4gYWx0ZXJuYXRpdmUgbmF2aWdhdGlvblxuICAgICAqIHdpdGggYFtjbHJXaXphcmRQcmV2ZW50RGVmYXVsdE5leHRdYC4gVGhlIHdpemFyZCB3aWxsIG1vdmUgdG8gdGhlIG5leHQgcGFnZVxuICAgICAqIHJlZ2FyZGxlc3Mgb2YgdGhlIHN0YXRlIG9mIGl0cyBjdXJyZW50IHBhZ2UuIFRoaXMgaXMgdXNlZnVsIGZvciBhbHRlcm5hdGl2ZVxuICAgICAqIG5hdmlnYXRpb24gd2hlcmUgZXZlbnQgZW1pc3Npb25zIGhhdmUgYWxyZWFkeSBiZWVuIGRvbmUgYW5kIGZpcmluZyB0aGVtIGFnYWluXG4gICAgICogbWF5IGNhdXNlIGFuIGV2ZW50IGxvb3AuXG4gICAgICpcbiAgICAgKiBJZiBgc2tpcENoZWNrc0FuZEVtaXRzYCBpcyBmYWxzZSwgdGhlIHdpemFyZCB3aWxsIGV4ZWN1dGUgZGVmYXVsdCBjaGVja3NcbiAgICAgKiBhbmQgZW1pdCBldmVudHMgYXMgbm9ybWFsLiBUaGlzIGlzIHVzZWZ1bCBmb3IgY3VzdG9tIGJ1dHRvbnMgb3IgcHJvZ3JhbW1hdGljXG4gICAgICogd29ya2Zsb3dzIHRoYXQgYXJlIG5vdCBleGVjdXRpbmcgdGhlIHdpemFyZHMgZGVmYXVsdCBjaGVja3MgYW5kIGVtaXNzaW9ucy5cbiAgICAgKiBJdCBpcyBhbm90aGVyIHdheSB0byBuYXZpZ2F0ZSB3aXRob3V0IGhhdmluZyB0byByZXdyaXRlIHRoZSB3aXphcmTigJlzIGRlZmF1bHRcbiAgICAgKiBmdW5jdGlvbmFsaXR5IGZyb20gc2NyYXRjaC5cbiAgICAgKi9cbiAgICBuZXh0KHNraXBDaGVja3NBbmRFbWl0cz86IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSB3aXphcmQgdG8gdGhlIG5leHQgcGFnZSB3aXRob3V0IHRoZSBjaGVja3MgYW5kIGVtaXNzaW9ucy5cbiAgICAgKiBHb29kIGZvciBhIGxhc3Qgc3RlcCBpbiBhbiBhbHRlcm5hdGUgd29ya2Zsb3cuXG4gICAgICogQWxpYXMgZm9yIGBDbHJXaXphcmQubmV4dCh0cnVlKWAgb3IgYENscldpemFyZC5uZXh0KClgXG4gICAgICovXG4gICAgZm9yY2VOZXh0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhbmQgY2xvc2VzIHRoZSB3aXphcmQuIERvIG5vdCB1c2UgdGhpcyBmb3IgYW4gb3ZlcnJpZGUgb2YgdGhlIGNhbmNlbFxuICAgICAqIHRoZSBmdW5jdGlvbmFsaXR5IHdpdGggYFtjbHJXaXphcmRQcmV2ZW50RGVmYXVsdENhbmNlbF1gLCBgW2NscldpemFyZFByZXZlbnRQYWdlRGVmYXVsdENhbmNlbF1gLFxuICAgICAqIG9yIGBbY2xyV2l6YXJkUGFnZVByZXZlbnREZWZhdWx0XWAgYmVjYXVzZSBpdCB3aWxsIGluaXRpYXRlIHRoZSBzYW1lIGNoZWNrc1xuICAgICAqIGFuZCBldmVudCBlbWlzc2lvbnMgdGhhdCBpbnZva2VkIHlvdXIgZXZlbnQgaGFuZGxlci4gVXNlIGBDbHJXaXphcmQuY2xvc2UoKWAgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBjYW5jZWwoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYmVoYXZpb3Igb2YgdGhlIHVuZGVybHlpbmcgbW9kYWwgdG8gYXZvaWQgY29sbGlzaW9ucyB3aXRoXG4gICAgICogYWx0ZXJuYXRpdmUgY2FuY2VsIGZ1bmN0aW9uYWxpdHkuIEluIG1vc3QgY2FzZXMsIHVzZSBgQ2xyV2l6YXJkLmNhbmNlbCgpYCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIG1vZGFsQ2FuY2VsKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGZvciBhbHRlcm5hdGl2ZSBjYW5jZWwgZmxvd3MgZGVmaW5lZCBhdCB0aGUgY3VycmVudCBwYWdlIG9yXG4gICAgICogd2l6YXJkIGxldmVsLiBQZXJmb3JtcyBhIGNhbmNlbGVkIGlmIG5vdC4gRW1pdHMgZXZlbnRzIHRoYXQgaW5pdGlhdGVcbiAgICAgKiB0aGUgYWx0ZXJuYXRpdmUgY2FuY2VsIG91dHB1dHMgYChjbHJXaXphcmRQYWdlT25DYW5jZWwpYCBhbmQgYChjbHJXaXphcmRPbkNhbmNlbClgLlxuICAgICAqL1xuICAgIGNoZWNrQW5kQ2FuY2VsKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTmF2aWdhdGVzIHRvIGEgZ2l2ZW4gcGFnZSBpbiB0aGUgV2l6YXJkLiBOYXZpZ2F0aW9uIHdpbGwgaW52b2tlIHRoZSB3aXphcmTigJlzIGRlZmF1bHRcbiAgICAgKiBjaGVja3MgYW5kIGV2ZW50IGVtaXNzaW9ucy5cbiAgICAgKlxuICAgICAqIFRoZSBmb3JtYXQgb2YgdGhlIGV4cGVjdGVkIElEIHBhcmFtZXRlciBjYW4gYmUgZm91bmQgaW4gdGhlIHJldHVybiBvZiB0aGVcbiAgICAgKiBDbHJXaXphcmRQYWdlLmlkIGdldHRlciwgdXN1YWxseSBwcmVmaXhlZCB3aXRoIGBjbHItd2l6YXJkLXBhZ2UtYCBhbmQgdGhlbiBlaXRoZXIgYVxuICAgICAqIG51bWVyaWMgSUQgb3IgdGhlIElEIHNwZWNpZmllZCBmb3IgdGhlIGBDbHJXaXphcmRQYWdlYCBjb21wb25lbnTigJlzIGBpZGAgaW5wdXQuXG4gICAgICovXG4gICAgZ29UbyhwYWdlSWQ6IHN0cmluZyk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUmVzZXQgc2V0cyBhbGwgV2l6YXJkUGFnZXMgdG8gaW5jb21wbGV0ZSBhbmQgc2V0cyB0aGUgZmlyc3QgcGFnZSBpbiB0aGUgYENscldpemFyZGAgdG9cbiAgICAgKiBiZSB0aGUgY3VycmVudCBwYWdlLCByZXNldHRpbmcgdGhlIHdpemFyZCBuYXZpZ2F0aW9uLlxuICAgICAqIFVzZSBgKGNscldpemFyZE9uUmVzZXQpYCBldmVudCB0byByZXNldCB0aGUgZGF0YSBvciBtb2RlbCBvZiB5b3VyIHdpemFyZC5cbiAgICAgKi9cbiAgICByZXNldCgpOiB2b2lkO1xuICAgIHByaXZhdGUgbGlzdGVuRm9yTmV4dFBhZ2VDaGFuZ2VzO1xuICAgIHByaXZhdGUgbGlzdGVuRm9yUHJldmlvdXNQYWdlQ2hhbmdlcztcbiAgICBwcml2YXRlIGxpc3RlbkZvckNhbmNlbENoYW5nZXM7XG4gICAgcHJpdmF0ZSBsaXN0ZW5Gb3JGaW5pc2hlZENoYW5nZXM7XG4gICAgcHJpdmF0ZSBsaXN0ZW5Gb3JQYWdlQ2hhbmdlcztcbiAgICBwcml2YXRlIHVwZGF0ZU5hdk9uUGFnZUNoYW5nZXM7XG4gICAgcHJpdmF0ZSBpbml0aWFsaXplQnV0dG9ucztcbiAgICBwcml2YXRlIGVtaXRXaXphcmRGaW5pc2hlZDtcbn1cbiJdfQ==